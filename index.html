<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Color Acuity Challenge</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;900&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg:       #0d0d14;
  --surface:  #161622;
  --surface2: #1e1e2e;
  --border:   rgba(255,255,255,0.07);
  --text:     #eeeef8;
  --muted:    #6868a0;
  --accent:   #a78bfa;
  --correct:  #4ade80;
  --wrong:    #f87171;
  --warn:     #fbbf24;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Outfit', system-ui, sans-serif;
  height: 100dvh;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  user-select: none;
}

/* ‚îÄ‚îÄ Screen system ‚îÄ‚îÄ */
.screen {
  position: absolute; inset: 0;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  padding: 1.5rem;
  transition: opacity .35s ease, transform .35s ease;
}
.screen.hidden { opacity: 0; pointer-events: none; transform: scale(.97); }

/* ‚îÄ‚îÄ Intro ‚îÄ‚îÄ */
#intro { gap: 2rem; text-align: center; }
.intro-blobs { position: absolute; inset: 0; overflow: hidden; z-index: -1; pointer-events: none; }
.blob {
  position: absolute; border-radius: 50%;
  filter: blur(90px); opacity: .13;
  animation: blobFloat 9s ease-in-out infinite;
}
@keyframes blobFloat {
  0%,100% { transform: translateY(0) scale(1); }
  50%      { transform: translateY(-28px) scale(1.06); }
}
.logo-wrap { line-height: 1; }
.logo {
  font-size: clamp(2.8rem, 9vw, 5rem);
  font-weight: 900; letter-spacing: -.03em;
  background: linear-gradient(130deg, #c084fc 0%, #f472b6 38%, #fb923c 72%, #fbbf24 100%);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
}
.logo-sub {
  font-size: .72rem; color: var(--muted);
  letter-spacing: .28em; text-transform: uppercase;
  font-weight: 400; margin-top: .5rem;
}
.rule-grid {
  display: grid; grid-template-columns: 1fr 1fr;
  gap: .7rem; max-width: 460px; width: 100%;
}
.rule-card {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 14px; padding: 1rem 1.2rem;
  text-align: left; transition: border-color .2s;
}
.rule-card:hover { border-color: rgba(167,139,250,.35); }
.rule-icon  { font-size: 1.35rem; margin-bottom: .45rem; line-height: 1; }
.rule-label { font-size: .6rem; color: var(--muted); text-transform: uppercase; letter-spacing: .14em; margin-bottom: .2rem; }
.rule-val   { font-size: .88rem; font-weight: 500; }

/* ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ */
.btn-main {
  background: linear-gradient(135deg, #7c3aed, #db2777);
  color: #fff; border: none; padding: .9rem 3rem;
  font-size: 1.05rem; font-weight: 600; border-radius: 100px;
  cursor: pointer; font-family: inherit;
  box-shadow: 0 8px 30px rgba(124,58,237,.35); letter-spacing: .02em;
  transition: transform .18s, box-shadow .18s;
}
.btn-main:hover { transform: translateY(-2px); box-shadow: 0 14px 40px rgba(124,58,237,.45); }
.btn-main:active { transform: translateY(0); }

.btn-sub {
  background: var(--surface2); border: 1px solid var(--border); color: var(--text);
  padding: .72rem 2rem; font-size: .95rem; font-weight: 500; border-radius: 100px;
  cursor: pointer; font-family: inherit; flex-shrink: 0;
  transition: background .18s, border-color .18s, transform .15s;
}
.btn-sub:hover { background: rgba(167,139,250,.15); border-color: var(--accent); transform: translateY(-1px); }
.btn-sub:active { transform: translateY(0); }

/* ‚îÄ‚îÄ Game screen ‚îÄ‚îÄ */
#game { gap: 0; padding: 1rem; }
.hud {
  width: 100%; max-width: 560px;
  display: flex; align-items: center; justify-content: space-between;
  padding-bottom: 1rem;
}
.hud-stat { display: flex; flex-direction: column; gap: .12rem; min-width: 64px; }
.hud-stat:nth-child(2) { align-items: center; }
.hud-stat:last-child   { align-items: flex-end; }
.hud-label     { font-size: .58rem; color: var(--muted); text-transform: uppercase; letter-spacing: .15em; }
.hud-val       { font-size: 1.5rem; font-weight: 700; line-height: 1; }
.hud-round-row { display: flex; align-items: baseline; gap: .35rem; }
.hud-lv-badge  { font-size: .72rem; font-weight: 600; color: var(--muted); }
.hud-dots      { display: flex; gap: 4px; margin-top: .1rem; }
.hud-dot       { width: 7px; height: 7px; border-radius: 50%; background: var(--surface2); border: 1px solid var(--border); transition: background .3s, border-color .3s; }
.hud-dot.done  { background: var(--correct); border-color: var(--correct); }
.hud-dot.now   { background: var(--accent); border-color: var(--accent); }
.hearts { display: flex; gap: 5px; }
.heart  { font-size: 1.2rem; transition: opacity .4s, transform .4s; }
.heart.gone { opacity: .15; transform: scale(.72); }
.timer-row {
  width: 100%; max-width: 560px;
  display: flex; align-items: center; gap: .75rem;
  margin-bottom: 1.25rem;
}
.timer-track { flex: 1; height: 7px; background: var(--surface2); border-radius: 4px; overflow: hidden; }
.timer-fill  { height: 100%; border-radius: 3px; width: 100%; transition: background-color .4s; }
.timer-num {
  font-size: .85rem; font-weight: 600; color: var(--muted);
  min-width: 26px; text-align: right; transition: color .3s;
}
.timer-num.urgent { color: var(--wrong); }

/* Grid */
#grid { display: grid; gap: 5px; }
.cell { border-radius: 8px; cursor: pointer; transition: transform .12s ease, box-shadow .12s ease; }
.cell:hover  { transform: scale(1.08); box-shadow: 0 6px 22px rgba(0,0,0,.55); position: relative; z-index: 1; }
.cell:active { transform: scale(.94); }
.cell.fx-correct { animation: fxCorrect .6s ease forwards; }
.cell.fx-wrong   { animation: fxWrong   .5s ease forwards; }
.cell.fx-reveal  {
  box-shadow: 0 0 0 3px #4ade80, 0 0 22px rgba(74,222,128,.45);
  transform: scale(1.1); position: relative; z-index: 2;
}
@keyframes fxCorrect {
  0%   { transform: scale(1);    box-shadow: 0 0 0 0    rgba(74,222,128,0);   }
  40%  { transform: scale(1.22); box-shadow: 0 0 0 14px rgba(74,222,128,.32); }
  70%  { transform: scale(1.05); box-shadow: 0 0 0 6px  rgba(74,222,128,.12); }
  100% { transform: scale(1);    box-shadow: 0 0 0 0    rgba(74,222,128,0);   }
}
@keyframes fxWrong {
  0%,100%{ transform: translateX(0); }
  20%    { transform: translateX(-9px); }
  40%    { transform: translateX( 9px); }
  60%    { transform: translateX(-5px); }
  80%    { transform: translateX( 5px); }
}
/* Cell staggered entrance */
.cell { animation: cellIn .35s ease backwards; }
@keyframes cellIn {
  from { opacity: 0; transform: scale(.7); }
  to   { opacity: 1; transform: scale(1); }
}
/* Score pop animation */
@keyframes scorePop {
  0%   { transform: scale(1); }
  40%  { transform: scale(1.35); color: var(--correct); }
  100% { transform: scale(1); }
}
.hud-val.score-pop { animation: scorePop .45s ease; }

.game-hint { margin-top: 1rem; font-size: .72rem; color: var(--muted); letter-spacing: .12em; text-transform: uppercase; }

/* ‚îÄ‚îÄ Round complete overlay ‚îÄ‚îÄ */
#roundComplete {
  position: fixed; inset: 0;
  display: flex; align-items: center; justify-content: center;
  background: rgba(6, 6, 14, 0.82);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  z-index: 200; cursor: pointer;
}
#roundComplete.hidden { display: none; }
.rc-card {
  width: min(360px, 90vw);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 22px; overflow: hidden;
  opacity: 0; transform: scale(.88) translateY(20px);
  transition: opacity .3s ease, transform .3s ease;
}
#roundComplete.show .rc-card { opacity: 1; transform: scale(1) translateY(0); }
.rc-top {
  padding: 1.75rem 1.5rem 1.5rem;
  text-align: center;
  background: rgba(74,222,128,.07);
  border-bottom: 1px solid rgba(74,222,128,.12);
}
.rc-check { font-size: 2rem; color: var(--correct); line-height: 1; margin-bottom: .35rem; }
.rc-title { font-size: 1.35rem; font-weight: 800; color: var(--correct); }
.rc-pts   { font-size: .9rem; font-weight: 600; color: var(--correct); opacity: .7; margin-top: .25rem; }
.rc-divider { height: 1px; background: var(--border); }
.rc-next {
  padding: 1.4rem 1.5rem 1.6rem;
  text-align: center;
  background: rgba(109,40,217,.14);
}
.rc-next-label {
  font-size: .6rem; text-transform: uppercase; letter-spacing: .18em;
  color: #a5b4fc; margin-bottom: .5rem;
}
.rc-next-title {
  font-size: 1.15rem; font-weight: 800;
  color: var(--text); margin-bottom: .55rem;
}
.rc-next-dims {
  font-size: .85rem; color: #c4b5fd; font-weight: 500; line-height: 1.7;
  white-space: pre-line;
}
.rc-note {
  margin-top: .6rem; font-size: .78rem;
  color: var(--warn); font-weight: 600;
}
.rc-tap { margin-top: .9rem; font-size: .65rem; color: var(--muted); letter-spacing: .1em; text-transform: uppercase; }

/* ‚îÄ‚îÄ Feedback overlay ‚îÄ‚îÄ */
#feedback {
  background: rgba(10,10,18,.93);
  backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px);
}
.fb-card {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 24px; padding: 1.75rem;
  max-width: 440px; width: 94%;
  display: flex; flex-direction: column; gap: 1.1rem;
  max-height: 92dvh; overflow: hidden;
}
.fb-header { text-align: center; flex-shrink: 0; }
.fb-result { font-size: 1.2rem; font-weight: 700; line-height: 1.3; }
.fb-result.ok  { color: var(--correct); }
.fb-result.bad { color: var(--wrong);   }
.fb-sub { font-size: .72rem; color: var(--muted); letter-spacing: .05em; margin-top: .3rem; }
.score-pill {
  display: inline-block; background: rgba(74,222,128,.15);
  color: var(--correct); font-size: .75rem; font-weight: 600;
  padding: .15rem .6rem; border-radius: 100px; margin-left: .4rem;
}

/* Scrollable body */
.fb-body {
  overflow-y: auto; flex: 1;
  display: flex; flex-direction: column; gap: .7rem;
  padding-right: 2px;
}
.fb-body::-webkit-scrollbar { width: 3px; }
.fb-body::-webkit-scrollbar-track { background: transparent; }
.fb-body::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

/* ‚îÄ‚îÄ Single-level view (wrong/timeout) ‚îÄ‚îÄ */
.compare-row { display: flex; align-items: stretch; gap: .9rem; }
.swatch-col  { flex: 1; display: flex; flex-direction: column; align-items: center; gap: .55rem; }
.swatch      { width: 70px; height: 70px; border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,.5); flex-shrink: 0; }
.swatch-lbl  { font-size: .6rem; color: var(--muted); text-transform: uppercase; letter-spacing: .1em; }
.hsl-tbl     { width: 100%; border-collapse: collapse; font-size: .78rem; }
.hsl-tbl td  { padding: .18rem .25rem; color: var(--muted); }
.hsl-tbl td:last-child { text-align: right; color: var(--text); font-weight: 500; }
.hsl-tbl tr.hi td { color: var(--accent); font-weight: 700; }
.compare-sep { width: 1px; background: var(--border); align-self: stretch; }
.analysis-box  { background: var(--surface2); border-radius: 12px; padding: .9rem 1rem; }
.analysis-head { font-size: .58rem; text-transform: uppercase; letter-spacing: .15em; color: var(--muted); margin-bottom: .5rem; }
.analysis-body { font-size: .85rem; line-height: 1.65; }
.a-tag  { display: inline-block; background: rgba(167,139,250,.15); color: var(--accent); padding: .05rem .5rem; border-radius: 4px; font-weight: 600; font-size: .8rem; }
.a-desc { display: block; margin-top: .45rem; font-size: .77rem; color: var(--muted); line-height: 1.55; }

/* ‚îÄ‚îÄ Round entry cards (summary) ‚îÄ‚îÄ */
.round-entry {
  background: var(--surface2); border-radius: 12px;
  padding: .85rem .95rem;
  display: flex; flex-direction: column; gap: .55rem;
  border: 1px solid var(--border);
}
.re-head {
  display: flex; align-items: center; justify-content: space-between;
}
.re-lv {
  font-size: .6rem; font-weight: 700;
  text-transform: uppercase; letter-spacing: .14em; color: var(--muted);
}
.re-dim { font-size: .78rem; font-weight: 500; color: var(--text); }
.re-delta { color: var(--accent); font-weight: 700; }
.re-body { display: flex; align-items: center; gap: .8rem; }
.re-swatches { display: flex; align-items: center; gap: .35rem; flex-shrink: 0; }
.re-sw-wrap  { display: flex; flex-direction: column; align-items: center; gap: .28rem; }
.re-sw       { width: 44px; height: 44px; border-radius: 8px; box-shadow: 0 3px 10px rgba(0,0,0,.4); }
.re-sw-lbl   { font-size: .52rem; color: var(--muted); text-transform: uppercase; letter-spacing: .07em; }
.re-arrow    { font-size: .85rem; color: var(--muted); padding-bottom: 14px; }
.re-hsl      { flex: 1; border-collapse: collapse; font-size: .75rem; }
.re-hsl td   { padding: .11rem .18rem; color: var(--muted); }
.re-hsl td:first-child  { font-weight: 600; min-width: 14px; }
.re-hsl td:nth-child(2) { color: var(--text); }
.re-hsl .re-sep { color: var(--muted); opacity: .4; padding: 0 .1rem; }
.re-hsl td:last-child   { text-align: right; color: var(--text); font-weight: 500; }
.re-hsl tr.hi td        { color: var(--accent); font-weight: 700; }

/* ‚îÄ‚îÄ Difficulty cards (summary page) ‚îÄ‚îÄ */
.diff-card {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: .85rem 1rem;
}
.diff-card-next {
  background: rgba(109, 40, 217, 0.22);
  border-color: rgba(167,139,250,.55);
  box-shadow: 0 4px 24px rgba(124,58,237,.18), inset 0 0 32px rgba(167,139,250,.06);
}
.dc-head {
  font-size: .6rem; font-weight: 700;
  text-transform: uppercase; letter-spacing: .14em;
  color: var(--muted); margin-bottom: .35rem;
}
.diff-card-next .dc-head {
  color: #c4b5fd;
  font-size: .65rem;
}
.dc-meta {
  font-size: .78rem; color: var(--text);
  font-weight: 500; margin-bottom: .55rem;
}
.diff-card-next .dc-meta {
  font-size: .9rem; font-weight: 600;
}
.dc-dims { display: flex; flex-direction: column; gap: .22rem; }
.dc-row  { display: flex; justify-content: space-between; font-size: .78rem; }
.diff-card-next .dc-row { font-size: .88rem; }
.dc-key  { color: var(--muted); }
.dc-val  { color: var(--text); font-weight: 600; }
.dc-accent { color: var(--accent); }
.diff-card-next .dc-key { color: #a5b4fc; }
.diff-card-next .dc-accent { color: #e9d5ff; font-weight: 700; }

/* ‚îÄ‚îÄ Game over ‚îÄ‚îÄ */
#gameover { gap: 1.75rem; text-align: center; }
.go-title { font-size: clamp(2rem, 7vw, 3.5rem); font-weight: 900; letter-spacing: -.03em; }
.go-rating-pill {
  display: inline-flex; align-items: center; padding: .5rem 1.5rem;
  border-radius: 100px; background: linear-gradient(135deg, #7c3aed, #db2777);
  font-weight: 600; font-size: 1rem; box-shadow: 0 4px 24px rgba(124,58,237,.32);
}
.go-rating-desc { margin-top: .4rem; font-size: .82rem; color: var(--muted); }
.go-stats { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; max-width: 380px; width: 100%; }
.go-stat { background: var(--surface); border: 1px solid var(--border); border-radius: 14px; padding: 1rem; text-align: center; }
.go-stat-lbl { font-size: .6rem; text-transform: uppercase; letter-spacing: .12em; color: var(--muted); margin-bottom: .25rem; }
.go-stat-val { font-size: 2rem; font-weight: 700; }
</style>
</head>
<body>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê INTRO ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="screen" id="intro">
  <div class="intro-blobs" id="blobs"></div>
  <div class="logo-wrap">
    <div class="logo">Color Acuity</div>
    <div class="logo-sub">Color Sensitivity Challenge</div>
  </div>
  <div class="rule-grid">
    <div class="rule-card">
      <div class="rule-icon">üéØ</div>
      <div class="rule-label">Objective</div>
      <div class="rule-val">Find the odd color block</div>
    </div>
    <div class="rule-card">
      <div class="rule-icon">‚è±</div>
      <div class="rule-label">Timer</div>
      <div class="rule-val">Countdown each round</div>
    </div>
    <div class="rule-card">
      <div class="rule-icon">‚ù§Ô∏è</div>
      <div class="rule-label">Lives</div>
      <div class="rule-val">3 mistakes ends the game</div>
    </div>
    <div class="rule-card">
      <div class="rule-icon">üé®</div>
      <div class="rule-label">Difficulty</div>
      <div class="rule-val">Differences get subtler</div>
    </div>
  </div>
  <button class="btn-main" onclick="G.start()">Start Challenge</button>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê GAME ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="screen hidden" id="game">
  <div class="hud">
    <div class="hud-stat">
      <span class="hud-label">Round</span>
      <div class="hud-round-row">
        <span class="hud-val" id="hLv">1</span>
        <span class="hud-lv-badge" id="hLvBadge">Lv.1</span>
      </div>
      <div class="hud-dots" id="hDots">
        <span class="hud-dot"></span><span class="hud-dot"></span><span class="hud-dot"></span>
      </div>
    </div>
    <div class="hud-stat">
      <span class="hud-label">Lives</span>
      <div class="hearts">
        <span class="heart" data-i="0">‚ô•</span>
        <span class="heart" data-i="1">‚ô•</span>
        <span class="heart" data-i="2">‚ô•</span>
      </div>
    </div>
    <div class="hud-stat">
      <span class="hud-label">Score</span>
      <span class="hud-val" id="hSc">0</span>
    </div>
  </div>
  <div class="timer-row">
    <div class="timer-track"><div class="timer-fill" id="tFill"></div></div>
    <div class="timer-num" id="tNum">15</div>
  </div>
  <div id="grid"></div>
  <div class="game-hint">Find the odd one out</div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ROUND COMPLETE OVERLAY ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div id="roundComplete" class="hidden">
  <div class="rc-card">
    <div class="rc-top">
      <div class="rc-check">‚úì</div>
      <div class="rc-title" id="rcTitle">Round 1 Complete</div>
      <div class="rc-pts"   id="rcPts">+0 pts</div>
    </div>
    <div class="rc-divider"></div>
    <div class="rc-next">
      <div class="rc-next-label">Up Next</div>
      <div class="rc-next-title" id="rcNextTitle">Round 2 ¬∑ Level 1</div>
      <div class="rc-next-dims"  id="rcNextDims"></div>
      <div class="rc-note"       id="rcNote"></div>
    </div>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê FEEDBACK ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="screen hidden" id="feedback">
  <div class="fb-card">
    <div class="fb-header">
      <div class="fb-result" id="fbResult"></div>
      <div class="fb-sub"    id="fbSub"></div>
    </div>
    <div class="fb-body" id="fbBody"></div>
    <button class="btn-sub" id="fbBtn">Continue ‚Üí</button>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê GAME OVER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="screen hidden" id="gameover">
  <div class="go-title">Game Over</div>
  <div>
    <div class="go-rating-pill" id="goRating">Novice Eye</div>
    <div class="go-rating-desc" id="goRatingDesc">Keep practicing to sharpen your perception</div>
  </div>
  <div class="go-stats">
    <div class="go-stat">
      <div class="go-stat-lbl">Total Score</div>
      <div class="go-stat-val" id="goScore">0</div>
    </div>
    <div class="go-stat">
      <div class="go-stat-lbl">Highest Round</div>
      <div class="go-stat-val" id="goLevel">1</div>
    </div>
    <div class="go-stat">
      <div class="go-stat-lbl">Level Reached</div>
      <div class="go-stat-val" id="goTier">‚Äî</div>
    </div>
    <div class="go-stat">
      <div class="go-stat-lbl">Accuracy</div>
      <div class="go-stat-val" id="goAcc">‚Äî</div>
    </div>
  </div>
  <button class="btn-main" onclick="G.restart()">Try Again</button>
</div>

<script>
/* ‚îÄ‚îÄ Sound Effects (Web Audio API) ‚îÄ‚îÄ */
const SFX = (() => {
  let ctx;
  function getCtx() {
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    return ctx;
  }

  function tone(freq, dur, type, startDelay, vol) {
    const c = getCtx();
    const t = c.currentTime + (startDelay || 0);
    const osc = c.createOscillator();
    const g = c.createGain();
    osc.type = type || 'sine';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(vol || 0.3, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur);
    osc.connect(g); g.connect(c.destination);
    osc.start(t); osc.stop(t + dur);
  }

  return {
    start() {
      getCtx().resume();
      tone(523, 0.1, 'sine', 0, 0.2);
      tone(659, 0.1, 'sine', 0.1, 0.2);
      tone(784, 0.15, 'sine', 0.2, 0.25);
    },
    tap()   { tone(800, 0.06, 'sine', 0, 0.12); },
    correct() { tone(523, 0.12, 'sine', 0, 0.25); tone(659, 0.18, 'sine', 0.1, 0.25); },
    wrong()   { tone(300, 0.15, 'square', 0, 0.18); tone(220, 0.2, 'square', 0.1, 0.18); },
    timeout() { tone(350, 0.2, 'triangle', 0, 0.2); tone(250, 0.35, 'triangle', 0.12, 0.18); },
    roundComplete() {
      tone(523, 0.1, 'sine', 0, 0.2);
      tone(659, 0.1, 'sine', 0.08, 0.2);
      tone(784, 0.18, 'sine', 0.16, 0.25);
    },
    checkpoint() {
      tone(523, 0.1, 'sine', 0, 0.22);
      tone(659, 0.1, 'sine', 0.1, 0.22);
      tone(784, 0.1, 'sine', 0.2, 0.22);
      tone(1047, 0.25, 'sine', 0.3, 0.28);
    },
    gameOver() {
      tone(523, 0.2, 'sine', 0, 0.22);
      tone(440, 0.2, 'sine', 0.2, 0.2);
      tone(349, 0.4, 'sine', 0.4, 0.18);
    },
    tick() { tone(1000, 0.04, 'sine', 0, 0.1); },
  };
})();

const G = (() => {

  /* ‚îÄ‚îÄ State ‚îÄ‚îÄ */
  let lv, score, lives, locked;
  let base, diff, diffIdx, dim, diffAmt, gridN, timeLimit;
  let rafId, levelT0;
  // Stores data for the 3 levels in the current round (slots 0‚Äì2)
  let roundData;
  let totalCorrect, totalAttempts;

  /* ‚îÄ‚îÄ Config ‚îÄ‚îÄ */
  const RATINGS = [
    { min:  1, label: 'Novice Eye',   desc: 'Your color journey is just beginning' },
    { min:  4, label: 'Apprentice',   desc: 'Picking up on obvious color shifts' },
    { min:  7, label: 'Sharp Eye',    desc: 'A solid foundation of color sense' },
    { min: 10, label: 'Gold Sense',   desc: 'Above-average color discrimination' },
    { min: 13, label: 'Color Master', desc: 'Near professional-grade perception' },
    { min: 16, label: 'Legend',       desc: 'Extraordinary chromatic sensitivity' },
  ];

  const DIM_INFO = {
    hue: {
      name: 'Hue', unit: '¬∞', wrap: true, key: 'h',
      desc: 'Hue is a color\'s angle on the color wheel ‚Äî its "which color" property. Even a small hue shift is detectable by a trained eye.',
    },
    saturation: {
      name: 'Saturation', unit: '%', wrap: false, key: 's',
      desc: 'Saturation controls color purity. High saturation is vivid; low is grey. Mid-tone saturation differences are the hardest to spot.',
    },
    lightness: {
      name: 'Lightness', unit: '%', wrap: false, key: 'l',
      desc: 'Lightness controls brightness from black to white. Subtle lightness shifts challenge even professional artists.',
    },
  };

  /* ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ */
  const $ = id => document.getElementById(id);
  const hsl = c => `hsl(${c.h.toFixed(2)},${c.s.toFixed(2)}%,${c.l.toFixed(2)}%)`;

  function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.toggle('hidden', s.id !== id));
  }

  // ‚îÄ‚îÄ Difficulty tiers (one tier per round, i.e. every 3 levels) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // gridN caps at 6. dim lists which dimensions can appear this round.
  // hue/lightness/saturation values are the fixed shift amount for that tier.
  const TIERS = [
    { label: 'Warm-Up',    gridN: 4, timeLimit: 15, dim: ['hue'],                            hue: 28, lightness: null, saturation: null },
    { label: 'Developing', gridN: 5, timeLimit: 13, dim: ['hue', 'lightness'],               hue: 20, lightness: 12,  saturation: null },
    { label: 'Challenging',gridN: 6, timeLimit: 11, dim: ['hue', 'lightness', 'saturation'], hue: 14, lightness:  8,  saturation: 15   },
    { label: 'Advanced',   gridN: 6, timeLimit:  9, dim: ['hue', 'lightness', 'saturation'], hue: 10, lightness:  5,  saturation: 10   },
    { label: 'Expert',     gridN: 6, timeLimit:  9, dim: ['hue', 'lightness', 'saturation'], hue:  7, lightness:  3,  saturation:  6   },
    { label: 'Master',     gridN: 6, timeLimit:  9, dim: ['hue', 'lightness', 'saturation'], hue:  4, lightness:  2,  saturation:  3   },
  ];

  function getTier(l) {
    const roundIdx = Math.ceil(l / 3) - 1;          // round index, 0-based
    return TIERS[Math.min(roundIdx, TIERS.length - 1)];
  }

  function deltaStr(d) {
    const info = DIM_INFO[d.dim];
    let delta = d.diff[info.key] - d.base[info.key];
    if (info.wrap) delta = ((delta + 180) % 360) - 180;
    return `${delta >= 0 ? '+' : ''}${delta.toFixed(1)}${info.unit}`;
  }

  /* ‚îÄ‚îÄ Level data capture ‚îÄ‚îÄ */
  // Called whenever a level ends (correct, wrong, or timeout).
  // Slot index = (lv-1) % 3, so slots 0/1/2 map to positions within the 3-level round.
  // If a level is retried, the slot is overwritten with the latest attempt's data.
  function captureLevelData(result) {
    roundData[(lv - 1) % 3] = {
      lv,
      base: { ...base },
      diff: { ...diff },
      dim,
      result,
    };
  }

  /* ‚îÄ‚îÄ Intro blobs ‚îÄ‚îÄ */
  function buildBlobs() {
    const wrap = $('blobs');
    wrap.innerHTML = '';
    ['#c084fc','#f472b6','#fb923c','#4ade80','#38bdf8','#fbbf24'].forEach((c, i) => {
      const el = document.createElement('div');
      el.className = 'blob';
      const sz = 180 + Math.random() * 220;
      Object.assign(el.style, {
        width: sz+'px', height: sz+'px', background: c,
        top: (Math.random()*85)+'%', left: (Math.random()*85)+'%',
        animationDelay: (i*1.4)+'s', animationDuration: (7+Math.random()*5)+'s',
      });
      wrap.appendChild(el);
    });
  }

  /* ‚îÄ‚îÄ HUD ‚îÄ‚îÄ */
  function renderHUD() {
    $('hLv').textContent      = lv;
    $('hLvBadge').textContent = `Lv.${Math.ceil(lv / 3)}`;
    $('hSc').textContent      = score;
    document.querySelectorAll('.heart').forEach((h, i) => h.classList.toggle('gone', i >= lives));
    // Progress dots: which of the 3 rounds in this level are done / current
    const pos = (lv - 1) % 3; // 0, 1, 2
    document.querySelectorAll('.hud-dot').forEach((dot, i) => {
      dot.className = 'hud-dot' + (i < pos ? ' done' : i === pos ? ' now' : '');
    });
  }

  /* ‚îÄ‚îÄ Timer ‚îÄ‚îÄ */
  function startTimer() {
    stopTimer();
    levelT0 = performance.now();
    let lastTickSec = Infinity;
    const fill = $('tFill'), numEl = $('tNum'), total = timeLimit * 1000;
    fill.style.transition = 'none';
    fill.style.width = '100%';
    fill.style.backgroundColor = 'var(--correct)';
    requestAnimationFrame(() => requestAnimationFrame(() => {
      fill.style.transition = `width ${timeLimit}s linear`;
      fill.style.width = '0%';
    }));
    function tick() {
      const elapsed = performance.now() - levelT0;
      const remaining = Math.max(0, total - elapsed);
      const pct = remaining / total;
      numEl.textContent = Math.ceil(remaining / 1000);
      numEl.classList.toggle('urgent', remaining < 4500);
      if (remaining < 5000 && remaining > 0) {
        const sec = Math.ceil(remaining / 1000);
        if (sec !== lastTickSec) { lastTickSec = sec; SFX.tick(); }
      }
      fill.style.backgroundColor = pct > .55 ? 'var(--correct)' : pct > .25 ? 'var(--warn)' : 'var(--wrong)';
      if (remaining > 0) { rafId = requestAnimationFrame(tick); }
      else { onTimeout(); }
    }
    rafId = requestAnimationFrame(tick);
  }

  function stopTimer() {
    cancelAnimationFrame(rafId);
    const fill = $('tFill');
    if (levelT0) {
      const pct = Math.max(0, 1 - (performance.now() - levelT0) / (timeLimit * 1000));
      fill.style.transition = 'none';
      fill.style.width = (pct * 100) + '%';
    }
  }

  function getTimeLeft() {
    return Math.max(0, timeLimit - (performance.now() - levelT0) / 1000);
  }

  /* ‚îÄ‚îÄ Grid ‚îÄ‚îÄ */
  function renderGrid() {
    const grid = $('grid');
    grid.style.gridTemplateColumns = `repeat(${gridN}, 1fr)`;
    grid.style.gridTemplateRows    = `repeat(${gridN}, 1fr)`;
    grid.innerHTML = '';
    const px = Math.max(240, Math.floor(Math.min(window.innerWidth * .90, window.innerHeight - 230, 520)));
    grid.style.width = grid.style.height = px + 'px';
    for (let i = 0; i < gridN * gridN; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.style.backgroundColor = hsl(i === diffIdx ? diff : base);
      cell.style.animationDelay = `${i * 25}ms`;
      cell.addEventListener('click', () => onCellClick(i));
      grid.appendChild(cell);
    }
  }

  /* ‚îÄ‚îÄ Level start ‚îÄ‚îÄ */
  function startLevel() {
    locked = false;
    const tier = getTier(lv);
    gridN     = tier.gridN;
    timeLimit = tier.timeLimit;
    dim       = tier.dim[Math.floor(Math.random() * tier.dim.length)];
    diffAmt   = tier[dim];
    const h = Math.random() * 360, s = 45 + Math.random() * 35, l = 38 + Math.random() * 27;
    base = { h, s, l };
    const sign = Math.random() < .5 ? 1 : -1;
    let dh = h, ds = s, dl = l;
    if      (dim === 'hue')       dh = (h + sign * diffAmt + 360) % 360;
    else if (dim === 'lightness') dl = Math.max(5, Math.min(95, l + sign * diffAmt));
    else                          ds = Math.max(5, Math.min(100, s + sign * diffAmt));
    diff = { h: dh, s: ds, l: dl };
    diffIdx = Math.floor(Math.random() * gridN * gridN);
    renderHUD(); renderGrid(); startTimer();
  }

  /* ‚îÄ‚îÄ Round complete overlay (non-summary rounds) ‚îÄ‚îÄ */
  function showRoundComplete(gained, cb) {
    SFX.roundComplete();
    const DIM_UNITS = { hue: '¬∞', lightness: '%', saturation: '%' };
    const DIM_LABEL = { hue: 'Hue', lightness: 'Lightness', saturation: 'Saturation' };

    const nextLv    = lv + 1;
    const levelNum  = Math.ceil(lv / 3);
    const tier      = getTier(lv);            // same tier for current and next within same level
    const posInLv   = lv % 3 || 3;           // 1, 2, or 3 within current level
    const isPreCheckpoint = posInLv === 2;    // next round (pos 3) triggers checkpoint

    const dimLines = tier.dim
      .map(d => `${DIM_LABEL[d]}  ¬±${tier[d]}${DIM_UNITS[d]}`)
      .join('\n');

    $('rcTitle').textContent    = `Round ${lv} Complete`;
    $('rcPts').textContent      = `+${gained} pts`;
    $('rcNextTitle').textContent = `Round ${nextLv}  ¬∑  Level ${levelNum}`;
    $('rcNextDims').textContent  = dimLines;
    $('rcNote').textContent      = isPreCheckpoint ? '‚öë  Checkpoint summary after this round' : '';

    // append tap-to-skip hint
    let tapEl = $('rcTap');
    if (!tapEl) {
      tapEl = document.createElement('div');
      tapEl.id = 'rcTap';
      tapEl.className = 'rc-tap';
      tapEl.textContent = 'tap anywhere to continue';
      document.querySelector('.rc-next').appendChild(tapEl);
    }

    const wrap = $('roundComplete');
    wrap.classList.remove('hidden');
    requestAnimationFrame(() => requestAnimationFrame(() => wrap.classList.add('show')));

    const dismiss = () => {
      clearTimeout(autoTimer);
      wrap.removeEventListener('click', dismiss);
      wrap.classList.remove('show');
      setTimeout(() => { wrap.classList.add('hidden'); cb && cb(); }, 300);
    };
    wrap.addEventListener('click', dismiss);
    const autoTimer = setTimeout(dismiss, 1000);
  }

  /* ‚îÄ‚îÄ Click handling ‚îÄ‚îÄ */
  function onCellClick(idx) {
    if (locked) return;
    if ($('game').classList.contains('hidden')) return;
    SFX.tap();
    locked = true;
    stopTimer();
    const cells = [...document.querySelectorAll('.cell')];
    if (idx === diffIdx) {
      cells[idx].classList.add('fx-correct');
      SFX.correct();
      const gained = lv * 100 + Math.round(getTimeLeft() * 15);
      score += gained;
      totalCorrect++; totalAttempts++;
      captureLevelData('correct');
      renderHUD();
      // Score pop animation
      const scEl = $('hSc');
      scEl.classList.remove('score-pop');
      void scEl.offsetWidth;
      scEl.classList.add('score-pop');
      if (lv % 3 === 0) {
        setTimeout(() => openFeedback('summary', gained), 650);
      } else {
        setTimeout(() => showRoundComplete(gained, () => { lv++; showScreen('game'); startLevel(); }), 500);
      }
    } else {
      cells[idx].classList.add('fx-wrong');
      SFX.wrong();
      lives--;
      totalAttempts++;
      renderHUD();
      captureLevelData('wrong');
      setTimeout(() => cells[diffIdx].classList.add('fx-reveal'), 320);
      setTimeout(() => openFeedback('wrong', 0), 920);
    }
  }

  function onTimeout() {
    if (locked) return;
    locked = true;
    SFX.timeout();
    lives--;
    totalAttempts++;
    renderHUD();
    captureLevelData('timeout');
    const cells = [...document.querySelectorAll('.cell')];
    cells[diffIdx].classList.add('fx-reveal');
    setTimeout(() => openFeedback('timeout', 0), 650);
  }

  /* ‚îÄ‚îÄ HTML builders ‚îÄ‚îÄ */

  // Build one row for the compact HSL table in round entries
  function hslRows(d) {
    return [
      { key:'H', bv:`${d.base.h.toFixed(1)}¬∞`, dv:`${d.diff.h.toFixed(1)}¬∞`, dim:'hue' },
      { key:'S', bv:`${d.base.s.toFixed(1)}%`, dv:`${d.diff.s.toFixed(1)}%`, dim:'saturation' },
      { key:'L', bv:`${d.base.l.toFixed(1)}%`, dv:`${d.diff.l.toFixed(1)}%`, dim:'lightness' },
    ];
  }

  // One round entry card (used in summary)
  function buildRoundEntry(d) {
    if (!d) return '';
    const info = DIM_INFO[d.dim];
    const ds   = deltaStr(d);
    return `
      <div class="round-entry">
        <div class="re-head">
          <span class="re-lv">Round ${d.lv}</span>
          <span class="re-dim">${info.name}&ensp;<span class="re-delta">${ds}</span></span>
        </div>
        <div class="re-body">
          <div class="re-swatches">
            <div class="re-sw-wrap">
              <div class="re-sw" style="background:${hsl(d.base)}"></div>
              <div class="re-sw-lbl">Base</div>
            </div>
            <span class="re-arrow">‚Üí</span>
            <div class="re-sw-wrap">
              <div class="re-sw" style="background:${hsl(d.diff)}"></div>
              <div class="re-sw-lbl">Odd</div>
            </div>
          </div>
          <table class="re-hsl">
            ${hslRows(d).map(r => `
              <tr class="${r.dim === d.dim ? 'hi' : ''}">
                <td>${r.key}</td>
                <td>${r.bv}</td>
                <td class="re-sep">‚Üí</td>
                <td>${r.dv}</td>
              </tr>`).join('')}
          </table>
        </div>
      </div>`;
  }

  // Single-level compare + analysis (used for wrong/timeout)
  function buildSingleBody(d) {
    const info = DIM_INFO[d.dim];
    const ds   = deltaStr(d);
    const rows = [
      { key:'H', val:`${d.diff.h.toFixed(1)}¬∞`, dim:'hue' },
      { key:'S', val:`${d.diff.s.toFixed(1)}%`, dim:'saturation' },
      { key:'L', val:`${d.diff.l.toFixed(1)}%`, dim:'lightness' },
    ];
    const baseRows = [
      { key:'H', val:`${d.base.h.toFixed(1)}¬∞` },
      { key:'S', val:`${d.base.s.toFixed(1)}%` },
      { key:'L', val:`${d.base.l.toFixed(1)}%` },
    ];
    return `
      <div class="compare-row">
        <div class="swatch-col">
          <div class="swatch" style="background:${hsl(d.base)}"></div>
          <div class="swatch-lbl">Base</div>
          <table class="hsl-tbl">
            ${baseRows.map(r => `<tr><td>${r.key}</td><td>${r.val}</td></tr>`).join('')}
          </table>
        </div>
        <div class="compare-sep"></div>
        <div class="swatch-col">
          <div class="swatch" style="background:${hsl(d.diff)}"></div>
          <div class="swatch-lbl">Odd</div>
          <table class="hsl-tbl">
            ${rows.map(r => `<tr class="${r.dim === d.dim ? 'hi' : ''}"><td>${r.key}</td><td>${r.val}</td></tr>`).join('')}
          </table>
        </div>
      </div>
      <div class="analysis-box">
        <div class="analysis-head">Color Analysis</div>
        <div class="analysis-body">
          Dimension: <span class="a-tag">${info.name}</span>&nbsp;&nbsp;Shift: <span class="a-tag">${ds}</span>
          <span class="a-desc">${info.desc}</span>
        </div>
      </div>`;
  }

  // Build the difficulty summary cards appended after round entries
  function buildDiffCards() {
    const DIM_UNITS = { hue: '¬∞', lightness: '%', saturation: '%' };
    const DIM_LABEL = { hue: 'Hue', lightness: 'Lightness', saturation: 'Saturation' };

    function tierCard(tier, title, accent) {
      const dimRows = tier.dim.map(d => `
        <div class="dc-row">
          <span class="dc-key">${DIM_LABEL[d]}</span>
          <span class="dc-val ${accent ? 'dc-accent' : ''}">¬±${tier[d]}${DIM_UNITS[d]}</span>
        </div>`).join('');
      return `
        <div class="diff-card ${accent ? 'diff-card-next' : ''}">
          <div class="dc-head">${title}</div>
          <div class="dc-meta">${tier.gridN}√ó${tier.gridN} grid &ensp;¬∑&ensp; ${tier.timeLimit}s / round</div>
          <div class="dc-dims">${dimRows}</div>
        </div>`;
    }

    const roundIdx  = Math.ceil(lv / 3) - 1;
    const curTier   = TIERS[Math.min(roundIdx, TIERS.length - 1)];
    const nextTier  = TIERS[Math.min(roundIdx + 1, TIERS.length - 1)];
    const isCapped  = roundIdx + 1 >= TIERS.length;
    const nextLabel = isCapped ? 'Next Level  (same difficulty)' : `Next Level ‚Äî ${nextTier.label}`;
    return tierCard(curTier, `This Level ‚Äî ${curTier.label}`, false)
         + tierCard(nextTier, nextLabel, !isCapped);
  }

  /* ‚îÄ‚îÄ Open feedback ‚îÄ‚îÄ */
  // mode: 'summary' | 'wrong' | 'timeout'
  function openFeedback(mode, gained) {
    const resEl = $('fbResult'), subEl = $('fbSub'), bodyEl = $('fbBody'), btn = $('fbBtn');

    if (mode === 'summary') {
      SFX.checkpoint();
      const round = Math.ceil(lv / 3);
      const start = lv - 2;
      resEl.innerHTML = `‚úì Checkpoint! <span class="score-pill">+${gained} pts</span>`;
      resEl.className = 'fb-result ok';
      subEl.textContent = `Level ${round} Complete ‚Äî Rounds ${start}‚Äì${lv}`;
      // 3 round entries + difficulty cards
      bodyEl.innerHTML = roundData.map(d => buildRoundEntry(d)).join('') + buildDiffCards();
      if (lives <= 0) {
        btn.textContent = 'See Results';
        btn.onclick = () => endGame();
      } else {
        btn.textContent = `Continue to Round ${lv + 1} ‚Üí`;
        btn.onclick = () => { lv++; showScreen('game'); startLevel(); };
      }
    } else {
      resEl.textContent = mode === 'timeout' ? '‚è± Time\'s Up!' : '‚úó Wrong!';
      resEl.className   = 'fb-result bad';
      subEl.textContent = 'The highlighted block was the odd one';
      // Use current level's data directly
      bodyEl.innerHTML  = buildSingleBody({ lv, base: {...base}, diff: {...diff}, dim });
      if (lives <= 0) {
        btn.textContent = 'See Results';
        btn.onclick = () => endGame();
      } else {
        btn.textContent = `Retry Round ${lv}`;
        btn.onclick = () => { showScreen('game'); startLevel(); };
      }
    }
    showScreen('feedback');
  }

  /* ‚îÄ‚îÄ Game over ‚îÄ‚îÄ */
  function endGame() {
    SFX.gameOver();
    const rating = [...RATINGS].reverse().find(r => lv >= r.min) || RATINGS[0];
    const tier = getTier(lv);
    const acc  = totalAttempts > 0 ? Math.round(totalCorrect / totalAttempts * 100) : 0;
    $('goScore').textContent      = score;
    $('goLevel').textContent      = lv;
    $('goTier').textContent       = tier.label;
    $('goAcc').textContent        = acc + '%';
    $('goRating').textContent     = rating.label;
    $('goRatingDesc').textContent = rating.desc;
    showScreen('gameover');
  }

  /* ‚îÄ‚îÄ Public API ‚îÄ‚îÄ */
  return {
    start() {
      SFX.start();
      lv = 1; score = 0; lives = 3; locked = false;
      roundData = [null, null, null];
      totalCorrect = 0; totalAttempts = 0;
      showScreen('game');
      startLevel();
    },
    restart() { buildBlobs(); showScreen('intro'); },
    init()    { buildBlobs(); },
  };
})();

G.init();
</script>
</body>
</html>
